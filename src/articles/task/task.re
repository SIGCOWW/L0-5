= JSPソルバでタスク管理...したい
@<author>{かふぇした}
//profile{
    ねぇ無理無理！（社会人）
//}

//lead{
    いやーキツいっす（社会人）
//}

== この記事のやりたいこと
  * @<b>{ジョブショップスケジューリング問題について解説します．}
  * @<b>{以上です．}

猛暑@<fn>{mosho}の中，皆さんはいかがお過ごしでしょうか．
私は今年から社会人になり，タスク管理の重要性を痛感しているところです．
//footnote[mosho][2018年8月現在]

タスク管理を定式化した組合せ最適化問題として，@<b>{スケジューリング問題}があげられます．
スケジューリング問題のなかでも，最も実用の例に近いとされる
@<b>{ジョブショップスケジューリング問題 (JSP; Job-shop Scheduling Problem)}は，
古くから研究の対象とされてきました．
JSPは，また，定義が単純かつ分かりやすい一方，厳密解法が判明していない困難な問題でもあるため，
@<b>{皆さん大好き巡回セールスマン問題}と共に，近似解法のベンチマークとしても広く利用されています．

今回は，JSPを含めたスケジューリング問題，およびその解法についてざぁっと説明します．
実装によるベンチマークは行いません@<fn>{zikan}．お兄さん許して！
//footnote[zikan][圧倒的に時間と気力が足りない]

== スケジューリング問題
スケジューリング問題は，処理されるべき@<b>{仕事}と，それを処理する@<b>{機械}によって構成されます．
仕事と機械はそれぞれ複数個存在し，各仕事は複数の機械によって処理されます．
@<img>{schedule}に，この状況を示します．
この例では，各仕事が機械A，機械B，機械Cの順で処理されます．
例えるなら，複数の鉄鋼品の製造（仕事A～C）を鋳造（機械A），圧延（機械B），加工（機械C）によって処理するようなイメージでしょうか．

//image[schedule][3機械3仕事のスケジューリング問題の例．][scale=0.8]

原則として，機械は，同時に複数の仕事を処理することはできません．また，仕事は，同時に複数の機械に処理されることはできません．
これらの制約を満たしたうえで，@<img>{schedule}の各仕事を処理する例を@<img>{make1}に示します．

//image[make1][@<img>{schedule}におけるガントチャートの例．][scale=1.0]

@<img>{make1}のように，縦軸に機械を取り，各機械が処理する仕事を時系列順に並べた図を@<b>{ガントチャート}と呼びます．
また，最初の仕事の開始時点（@<img>{make1}では機械Aが仕事Aの処理を開始する時点）から，最後の仕事の終了時点（@<img>{make1}では機械Bが仕事Cの処理を終了する時点）までの時間を@<b>{メイクスパン}
と呼びます．
スケジューリング問題は，このメイクスパンを最小にすることが主な目的になります．

@<img>{make1}は，何も考えず機械Aに仕事A，仕事B，仕事Cを投入し，各仕事が終わり次第，続く機械に仕事を投入しています．
しかし，（機械Aにとって）最も待ち時間が長い仕事Aを投入したばっかりに，機械Bと機械Cがかなり待たされています．
ここで，最も待ち時間が短い仕事Cを最初に投入した例を@<img>{make2}に示します．

//image[make2][@<img>{schedule}におけるガントチャートの例．@<img>{make1}よりもメイクスパンが短くなっていることに注目されたい．][scale=1.0]

@<img>{make2}を見ると，@<img>{make1}よりもメイクスパンが短くなっていることが分かります．
このように，単純な例でも仕事の処理手順によってメイクスパンが変化することが分かっていただけたかと思います．

=== スケジューリング問題の分類
スケジューリング問題は，機械の処理順序に対する制約により，次の3つに分類されます．

: オープンショップ問題 (OSP; Open-shop Scheduling Problem)
  仕事を処理する機械の順番が決まっていない問題を指します．@<img>{schedule}を例にとると，仕事Aを処理するのに，例えば機械C，機械B，機械Aの順番で処理して良いということになります．

: フローショップ問題 (FSP; Flow-shop Scheduling Problem)
  仕事を処理する機械の順番が決まっており，すべての仕事で処理順序が同じ問題を指します．@<img>{schedule}を例にとると，仕事Aを処理するためには，必ず機械A，機械B，機械Cの順番で処理しなければなりません．

: ジョブショップ問題 (JSP; Job-shop Scheduling Problem)
  仕事を処理する機械の順序が決まっており，各仕事において処理順序が違って良い問題を指します．@<img>{flowjob}に，FSPとJSPの違いを示します．

//image[flowjob][フローショップ問題とジョブショップ問題の比較．フローショップ問題ではすべての仕事の処理順序が同じであるのに対し，ジョブショップ問題ではこの制約が存在しない．][scale=0.8]

一般に，フローショップ問題よりもジョブショップ問題の方が困難であるとされています．
一方で，FSPをJSPの特殊例と考えれば，JSPの方がより実用に近いということができます．

=== その他の制約: 派生モデル
JSPは最も実用に近いと書きましたが，実用の場では様々な制約や派生が考えられます．

JSPにおける仕事の各工程において，複数の機械を選択可能とした拡張をフレキシブル・ジョブショップスケジューリング問題（F-JSP; Frexible JSB）と呼びます．
F-JSPはJSPの派生の中でも特に実用の問題に近いため，盛んに研究されている問題です．
F-JSPのように定式化された派生以外にも，
機械の起動・停止時間の制約@<fn>{machine1}，
段取り時間の制約@<fn>{machine2}，仕事ごとに決められた納期の遵守などによる派生が考えられます．
//footnote[machine1][@<img>{make2}において，機械の起動・停止に時間がかかる場合，機械Cのような細切れの作業はできないかもしれません．]
//footnote[machine2][段取り時間とは，同じ機械で違う仕事をするときに発生する取替時間のことを言います．たとえば，同じ機械で違う材料を処理するときに，内部の洗浄が必要とされる場面を想定しています．]

JSPを人間のタスク管理に応用したとき，すなわち機械を人として考えたときは，様々な制約が考えられます．
例えば，連続勤務時間の制約@<fn>{human1}，勤務時間帯希望の制約などが考えられます．
このような，人間特有の制約を考慮したスケジューリング問題をナーススケジューリング問題 (NSP; Nurse Scheduling Problem)とよびます．
//footnote[human1][@<img>{make2}の機械を人として捉えると，横軸のスケールによっては，機械Aと機械Bの人は過労死してしまうでしょう．]

== アルゴリズム

== おわりに
今回はスケジューリング問題について説明しました．
また機会があれば，ソルバの詳しい説明と，実装によるベンチマークを行う...かもしれません@<fn>{theme}．
内容薄くてすまんな．
//footnote[theme][TSPみたいに，やっててモチベーションが上がる問題を解きたい．]
